# Singly LinkedList (단일 연결리스트) 구현하기

실제 Java 에서 구현하고 있는 Linkedlikst 의 메소드는 다음과 같다. 
- https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/LinkedList.html

이 모든 것을 다 구현해보는 것은 무리가 있기에, 가장 핵심적인 메소드들 정도만 구현해보도록 하겠다. 

> 본 코드는 head 만 등록해놔 새로운 노드를 뒤에서 추가하는 addLast() 의 메소드 등을 구현하기 좀 까다로운데, head 와 tail 모두를 이용하여 더 다양한 메소드들을 구현해볼 수 있겠다. 링크 참고. https://st-lab.tistory.com/167?category=856997

## 
```java
public class LinkedList3<T>
{
    // Node 그 자체
    private class Node<T>
    {
        private T data;
        private Node<T> link;

        public Node( )
        {
             data = null;
             link = null;
        }

        public Node(T newData, Node<T> linkValue)
        {
            data = newData;
            link = linkValue;
        }
     }

    private Node<T> head;

    public LinkedList3( )
    {
        head = null;
    }

    /**
     새 노드를 앞에 추가하는 메소드
    */
    public void addToStart(T itemData)
    {
        head = new Node<T>(itemData, head);  //생성자에서 head의 link 값도 받도록 구현했음. 기존의 head 가 새 head 의 link가 되는 것임. (addToStart 이므로) 
    }

    /**
     앞 노드인 head 를 삭제하는 메소드
    */
    public boolean deleteHeadNode( )
    {
        if (head != null)
        {
            head = head.link;   //기존의 head 의 link 를 head 로 임명
            return true;
        }
        else
            return false;
    }

    /**
     노드 수 반환
    */
    public int size( )
    {
        int count = 0;
        Node<T> position = head;
        while (position != null)
        {
            count++;
            position = position.link;
        }
        
        /*
        for (Node<T> position = head ; position != null ; position = position.link){
          count++;
        }
        */
        
        return count;
    }

    /**
    특정 위치의 노드를 반환하는 메소드
    */
    private Node<T> search(int index) {

      // 범위 밖(잘못된 위치)일 경우 예외 던지기 
      if(index < 0 || index >= size) {
        throw new IndexOutOfBoundsException();
      }

      Node<T> x = head;	// head가 기리키는 노드부터 시작 

      for (int i = 0; i < index; i++) {
        x = x.next;	// x노드의 다음 노드를 x에 저장한다
      }
      return x;
    }
    
    /**
    search() 메소드는 '노드'를 반환하고, get() 메소드는 '노드의 데이터'를 반환
    */
    public T get(int index) {
	    return search(index).data;
    }

    /**
    기존에 index에 위치한 데이터를 새로운 데이터(value)으로 교체
    */
    public void set(int index, T value) {

      Node<T> replaceNode = search(index);
      replaceNode.data = null;
      replaceNode.data = value;
    }
    
    /**
    찾고자 하는 요소(value)의 '위치(index)'를 반환
    */
    public int indexOf(Object value) {
      int index = 0;

      for (Node<E> x = head; x != null; x = x.next) {
        if (value.equals(x.data)) {   //객체끼리 비교할 때는 동등연산자(==)가 아니라 반드시 .equals() 로 비교해야 한다
          return index;
        }
        index++;
      }
      // 찾고자 하는 요소를 찾지 못했을 경우 -1 반환
      return -1;
    }

    /**
    사용자가 찾고자 하는 요소(value)가 존재 하는지 안하는지를 반환
    indexOf 메소드를 이용하여 만약 음수가 아닌 수가 반환되었다면 요소가 존재한다는 뜻이고, 음수(-1)이 나왔다면 요소가 존재하지 않는다는 뜻
    */
    public boolean contains(Object item) {
      return indexOf(item) >= 0;
    }

    public void outputList( )
    {
        Node<T> position = head;
        while (position != null)
        {
            System.out.println(position.data);
            position = position.link;
        }
    }

    public boolean isEmpty( )
    {
        return (head == null);
        // return size == 0;
    }

    public void clear( )
    {
        head = null;
    }

   /*
    For two lists to be equal they must contain the same data items in
    the same order. The equals method of T is used to compare data items.
   */
   public boolean equals(Object otherObject)
    {
        if (otherObject == null)
            return false;
        else if (getClass( ) != otherObject.getClass( ))
            return false;
        else
        {
            LinkedList3<T> otherList = (LinkedList3<T>)otherObject;
            if (size( ) != otherList.size( ))
                return false;
            Node<T> position = head;
            Node<T> otherPosition = otherList.head;
            while (position != null)
            {
                if (!(position.data.equals(otherPosition.data)))
                    return false;
                position = position.link;
                otherPosition = otherPosition.link;
            }
            return true; //no mismatch was not found
        }
    }

}

```



## Entry.java
```java

public class Entry
{
    private String item;
    private int count;

    public Entry(String itemData, int countData)
    {
        item = itemData;
        count = countData;
    }

    public String toString( )
    {
        return (item + " " + count);
    }

    public boolean equals(Object otherObject)
    {
        if (otherObject == null)
            return false;
        else if (getClass( ) != otherObject.getClass( ))
            return false;
        else
        {
            Entry otherEntry = (Entry)otherObject;
            return (item.equals(otherEntry.item) 
                      && (count == otherEntry.count));
        }
    }

   // <There should be other constructors and methods, including accessor and 
   //                       mutator methods, but we do not use them in this demonstration.>
}

```


## Main.java
```java
public class Main
{
    public static void main(String[] args)
    {
        LinkedList3<Entry> list = new LinkedList3<Entry>( );

        Entry entry1 = new Entry("Apples", 1);
        list.addToStart(entry1);
        Entry entry2 = new Entry("Bananas", 2);
        list.addToStart(entry2);
        Entry entry3 = new Entry("Cantaloupe", 3);
        list.addToStart(entry3);
        System.out.println("List has " + list.size( ) 
                            + " nodes.");
        list.outputList( );
        System.out.println("End of list.");
    }
}

```
